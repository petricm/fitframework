/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooDalitzAnalysis.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include "TH1.h"
#include "TFile.h"
#include <math.h>
#include "TMath.h"
#include "libComplexPDF/libComplexPDF.h"
#include "CacheIntegrator/CacheIntegrator.h"
#include "CacheIntegrator/DalitzAnalysisCore.h"
#include "CacheIntegrator/DalitzAnalysisNormCachedIntegral.h"
#include "CacheIntegrator/DalitzAnalysisRealCachedIntegral.h"
#include "CacheIntegrator/DalitzAnalysisImagCachedIntegral.h"

// include efficiency histogram for HIST_4D
//#include "efficiency_histogram_4D.cc"
double GetEff(const double mass_AB, const double mass_BC, EFFICIENCY_FUNCTION value) {
	switch (value) {
        case FLAT:
            return 1.0;
        case BIN_2D:
            TH1::AddDirectory(kFALSE);
            if (efficiency_graph_2D == NULL) {
                TFile* graph_file= new TFile("plots/efficiency_2D_mass_12_vs_mass_01.root","READ");
                efficiency_graph_2D = dynamic_cast<TGraph2D*>(graph_file->Get("Graph2D"));
                graph_file->Close();
            }
            return efficiency_graph_2D->Interpolate(mass_AB, mass_BC);
        case FIT_2D:
            return 1.0;//Implement efficiency function !!!!!
        default:
            std::cerr << "ERROR: Unknown acceptance function code " << value << " in GetEff(...)" << std::endl;
            break;
	}
	return 1.0;
}

ClassImp(RooDalitzAnalysis)

RooDalitzAnalysis::RooDalitzAnalysis(const char *name, const char *title,
                                     RooAbsReal& _mass_AB,
                                     RooAbsReal& _mass_BC,
                                     
                                     RooAbsReal& _mass_1,
                                     RooAbsReal& _width_1,
                                     
                                     RooAbsReal& _mass_2,
                                     RooAbsReal& _width_2,
                                     
                                     RooAbsReal& _mass_3,
                                     RooAbsReal& _width_3,
                                     
                                     RooAbsReal& _mass_4,
                                     RooAbsReal& _width_4,
                                     
                                     RooAbsReal& _mass_5,
                                     RooAbsReal& _width_5,
                                     
                                     RooAbsReal& _mass_6,
                                     RooAbsReal& _width_6,
                                     
                                     RooAbsReal& _mass_7,
                                     RooAbsReal& _width_7,
                                     
                                     RooAbsReal& _amp_1,
                                     RooAbsReal& _phase_1,
                                     RooAbsReal& _amp_2,
                                     RooAbsReal& _phase_2,
                                     RooAbsReal& _amp_3,
                                     RooAbsReal& _phase_3,
                                     RooAbsReal& _amp_4,
                                     RooAbsReal& _phase_4,
                                     RooAbsReal& _amp_5,
                                     RooAbsReal& _phase_5,
                                     RooAbsReal& _amp_6,
                                     RooAbsReal& _phase_6,
                                     RooAbsReal& _amp_7,
                                     RooAbsReal& _phase_7,
                                     RooAbsReal& _amp_8,
                                     RooAbsReal& _phase_8,
                                     
                                     EFFICIENCY_FUNCTION _efficiency_function,
                                     DAI_PDG_constants _s_PDG,
                                     DAI_Dalitz_Model_parameters _s_DM_pars,
                                     DAI_CacheIntegrators_2D _s_2D) :
                                        RooAbsPdf(name,title),
                                        mass_AB("mass_AB","mass_AB",this,_mass_AB),
                                        mass_BC("mass_BC","mass_BC",this,_mass_BC),
                                        mass_1("mass_1","mass_1",this,_mass_1),
                                        width_1("width_1","width_1",this,_width_1),
                                        mass_2("mass_2","mass_2",this,_mass_2),
                                        width_2("width_2","width_2",this,_width_2),
                                        mass_3("mass_3","mass_3",this,_mass_3),
                                        width_3("width_3","width_3",this,_width_3),
                                        mass_4("mass_4","mass_4",this,_mass_4),
                                        width_4("width_4","width_4",this,_width_4),
                                        mass_5("mass_5","mass_5",this,_mass_5),
                                        width_5("width_5","width_5",this,_width_5),
                                        mass_6("mass_6","mass_6",this,_mass_6),
                                        width_6("width_6","width_6",this,_width_6),
                                        mass_7("mass_7","mass_7",this,_mass_7),
                                        width_7("width_7","width_7",this,_width_7),
                                        amp_1("amp_1","amp_1",this,_amp_1),
                                        phase_1("phase_1","phase_1",this,_phase_1),
                                        amp_2("amp_2","amp_2",this,_amp_2),
                                        phase_2("phase_2","phase_2",this,_phase_2),
                                        amp_3("amp_3","amp_3",this,_amp_3),
                                        phase_3("phase_3","phase_3",this,_phase_3),
                                        amp_4("amp_4","amp_4",this,_amp_4),
                                        phase_4("phase_4","phase_4",this,_phase_4),
                                        amp_5("amp_5","amp_5",this,_amp_5),
                                        phase_5("phase_5","phase_5",this,_phase_5),
                                        amp_6("amp_6","amp_6",this,_amp_6),
                                        phase_6("phase_6","phase_6",this,_phase_6),
                                        amp_7("amp_7","amp_7",this,_amp_7),
                                        phase_7("phase_7","phase_7",this,_phase_7),
                                        amp_8("amp_8","amp_8",this,_amp_8),
                                        phase_8("phase_8","phase_8",this,_phase_8),
                                        m_Pi0(_s_PDG.m_Pi0),
                                        m_Pi(_s_PDG.m_Pi),
                                        m_K(_s_PDG.m_K),
                                        m_B0(_s_PDG.m_B0),
                                        m_efficiency_function(_efficiency_function),
                                        m_r_1(_s_DM_pars.m_r_1),
                                        m_a_2(_s_DM_pars.m_a_2),
                                        m_r_2(_s_DM_pars.m_r_2),
                                        m_cutoff_2(_s_DM_pars.m_cutoff_2),
                                        m_r_3(_s_DM_pars.m_r_3),
                                        m_r_4(_s_DM_pars.m_r_4),
                                        m_r_5(_s_DM_pars.m_r_5),
                                        m_r_6(_s_DM_pars.m_r_6),
                                        m_a_7(_s_DM_pars.m_a_7),
                                        m_r_7(_s_DM_pars.m_r_7),
                                        m_cutoff_7(_s_DM_pars.m_cutoff_7),
                                        m_norm_cache_integrator(_s_2D.norm_cache_integrator),
                                        m_real_cache_integrator(_s_2D.real_cache_integrator),
                                        m_imag_cache_integrator(_s_2D.imag_cache_integrator){
}

RooDalitzAnalysis::RooDalitzAnalysis(const RooDalitzAnalysis& other, const char* name) :
RooAbsPdf(other,name),
mass_AB("mass_AB",this,other.mass_AB),
mass_BC("mass_BC",this,other.mass_BC),
mass_1("mass_1",this,other.mass_1),
width_1("width_1",this,other.width_1),
mass_2("mass_2",this,other.mass_2),
width_2("width_2",this,other.width_2),
mass_3("mass_3",this,other.mass_3),
width_3("width_3",this,other.width_3),
mass_4("mass_4",this,other.mass_4),
width_4("width_4",this,other.width_4),
mass_5("mass_5",this,other.mass_5),
width_5("width_5",this,other.width_5),
mass_6("mass_6",this,other.mass_6),
width_6("width_6",this,other.width_6),
mass_7("mass_7",this,other.mass_7),
width_7("width_7",this,other.width_7),
amp_1("amp_1",this,other.amp_1),
phase_1("phase_1",this,other.phase_1),
amp_2("amp_2",this,other.amp_2),
phase_2("phase_2",this,other.phase_2),
amp_3("amp_3",this,other.amp_3),
phase_3("phase_3",this,other.phase_3),
amp_4("amp_4",this,other.amp_4),
phase_4("phase_4",this,other.phase_4),
amp_5("amp_5",this,other.amp_5),
phase_5("phase_5",this,other.phase_5),
amp_6("amp_6",this,other.amp_6),
phase_6("phase_6",this,other.phase_6),
amp_7("amp_7",this,other.amp_7),
phase_7("phase_7",this,other.phase_7),
amp_8("amp_8",this,other.amp_8),
phase_8("phase_8",this,other.phase_8),
m_Pi0(other.m_Pi0),
m_Pi(other.m_Pi),
m_K(other.m_K),
m_B0(other.m_B0),
m_efficiency_function(other.m_efficiency_function),
m_r_1(other.m_r_1),
m_a_2(other.m_a_2),
m_r_2(other.m_r_2),
m_cutoff_2(other.m_cutoff_2),
m_r_3(other.m_r_3),
m_r_4(other.m_r_4),
m_r_5(other.m_r_5),
m_r_6(other.m_r_6),
m_a_7(other.m_a_7),
m_r_7(other.m_r_7),
m_cutoff_7(other.m_cutoff_7),
m_norm_cache_integrator(other.m_norm_cache_integrator),
m_real_cache_integrator(other.m_real_cache_integrator),
m_imag_cache_integrator(other.m_imag_cache_integrator){
}

Double_t RooDalitzAnalysis::evaluate() const {
    
    //Calculate the roots and the third dalitz variable
    double MAB = std::sqrt(mass_AB);
    double MBC = std::sqrt(mass_BC);
    //double MCA = TMath::Sqrt(TMath::Abs(m_B0*m_B0 + m_K*m_K + m_Pi*m_Pi + m_Pi0*m_Pi0 - MAB*MAB - MBC*MBC)); //not needed, this variable is calculated inside ComplexPDF
    
    if(ComplexPDF::InsideDalitzLimits(MAB,MBC,m_B0,m_Pi0,m_Pi,m_K)){
        //Initialize the vecotr of amplitudes
        std::vector<std::complex<double> > a; a.reserve(8);
        a.push_back(std::polar((double)amp_1,(double)phase_1));
        a.push_back(std::polar((double)amp_2,(double)phase_2));
        a.push_back(std::polar((double)amp_3,(double)phase_3));
        a.push_back(std::polar((double)amp_4,(double)phase_4));
        a.push_back(std::polar((double)amp_5,(double)phase_5));
        a.push_back(std::polar((double)amp_6,(double)phase_6));
        a.push_back(std::polar((double)amp_7,(double)phase_7));
        a.push_back(std::polar((double)amp_8,(double)phase_8));
        
        std::vector<std::complex<double> > A; A.reserve(8);
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::CA, ComplexPDF::AB, mass_1, width_1, m_r_1, 1, m_B0, m_Pi0, m_Pi, m_K));//K*+
        A.push_back(ComplexPDF::GetLASSMatrixElement(MAB, MBC, ComplexPDF::CA, mass_2, width_2, m_a_2, m_r_2, m_cutoff_2, m_B0, m_Pi0, m_Pi, m_K)); //K*(1430)+ (Kpi S-wave)
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::AB, ComplexPDF::BC, mass_3, width_3, m_r_3, 1, m_B0, m_Pi0, m_Pi, m_K)); //rho(770)-
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::AB, ComplexPDF::BC, mass_4, width_4, m_r_4, 1, m_B0, m_Pi0, m_Pi, m_K)); //rho(2S)(1450)-
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::AB, ComplexPDF::BC, mass_5, width_5, m_r_5, 1, m_B0, m_Pi0, m_Pi, m_K)); //rho(3S)(1700)-
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::BC, ComplexPDF::CA, mass_6, width_6, m_r_6, 1, m_B0, m_Pi0, m_Pi, m_K));//K*(892)0
        A.push_back(ComplexPDF::GetLASSMatrixElement(MAB, MBC, ComplexPDF::BC, mass_7, width_7, m_a_7, m_r_7, m_cutoff_7, m_B0, m_Pi0, m_Pi, m_K)); //K*(1430)0 (Kpi S-wave)
        A.push_back(ComplexPDF::DalitzPhaseSpaceAmplitude(MAB,MBC)); //Non-Resonant
        
        std::complex<double> amplitude(0,0);
        for (unsigned int i=0; i<8; i++) {
            if (A[i]!=A[i]) {
                std::cerr << "ERROR: Matrix element for amplitude " <<i+1<<" is NAN!!!"<< std::endl;
                std::exit(EXIT_FAILURE);
            }else{
                amplitude += a[i]*A[i];
            }
        }
        
        double acceptance = GetEff(mass_AB, mass_BC, m_efficiency_function);
        
        return acceptance * std::norm(amplitude);
        
    }else{
        
        return 0.0;
    }
    
}

Int_t RooDalitzAnalysis::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
	
    if (matchArgs(allVars, analVars, mass_AB, mass_BC))
		return 1;
	//std::cerr << "INFO: Unsupported analytical integral was requested in RooDalitzAnalysis::getAnalyticalIntegral(...) " <<
	//		"--> Numeric integration will be used." <<  std::endl;
	return 0;
}

Double_t RooDalitzAnalysis::analyticalIntegral(Int_t code, const char* rangeName ) const {
	// index values regarding which ressonance pair we use
    const int N_RES = 8 ;
    
	const double J_values[8]      = {1, 2, 3, 4, 5, 6, 7, 8};
	// complex weights
	const double amps[8]  = {amp_1,  amp_2,  amp_3,  amp_4,  amp_5,  amp_6,  amp_7, amp_8};
	const double phase[8] = {phase_1, phase_2, phase_3, phase_4, phase_5, phase_6, phase_7, phase_8};
    
	// parameters index 0-17 are same for all integrals
	// index 18 is the acceptance function used
	// index 19 might be one of the variables
	std::vector<double> parameters;
	parameters.reserve(33);
	parameters.assign(32,0);
	// variable parameters (will be set in for loop below)
	parameters[0] = 0; // index of resonance
	parameters[1] = 0; // index of charged conjugate resonance
	// constant parameters for resonances
    parameters[2] = mass_1;
    parameters[3] = width_1;
    parameters[4] = m_r_1;
    parameters[5] = mass_2;
    parameters[6] = width_2;
    parameters[7] = m_a_2;
    parameters[8] = m_r_2;
    parameters[9] = m_cutoff_2;
    parameters[10] = mass_3;
    parameters[11] = width_3;
    parameters[12] = m_r_3;
    parameters[13] = mass_4;
    parameters[14] = width_4;
    parameters[15] = m_r_4;
    parameters[16] = mass_5;
    parameters[17] = width_5;
    parameters[18] = m_r_5;
    parameters[19] = mass_6;
    parameters[20] = width_6;
    parameters[21] = m_r_6;
    parameters[22] = mass_7;
    parameters[23] = width_7;
    parameters[24] = m_a_7;
    parameters[25] = m_r_7;
    parameters[26] = m_cutoff_7;
	// constant parameters
	parameters[27] = m_B0;
	parameters[28] = m_Pi0;
	parameters[29] = m_Pi;
	parameters[30] = m_K;
	// acceptance function
	parameters[31] = m_efficiency_function;
    
	if (code == 1) {
		std::vector<std::pair<double,double> > limits; limits.reserve(2);
		limits.push_back(std::make_pair(mass_AB.min(rangeName),mass_AB.max(rangeName)));
		limits.push_back(std::make_pair(mass_BC.min(rangeName),mass_BC.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
        
		// matrix element
		double M = 0;
		// calc each of the 64 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < N_RES; ++i) {
			for(unsigned int j = 0; j < N_RES; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = J_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[1]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator->GetIntegral(limits,parameters);
				}
			}
		}
        //std::cout<<M<<"\t"<<m_norm_cache_integrator->GetIntegral(limits,parameters)<<std::endl;
		return M;
	}
	std::cerr << "ERROR: Unsupported analytical integral code=" << code << " in RooDalitzAnalysis::analyticalIntegral(...) " <<
    "--> Return 0" << std::endl;
	return 0;
}

