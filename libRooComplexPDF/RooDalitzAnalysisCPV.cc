/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooDalitzAnalysisCPV.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"
#include "libComplexPDF/libComplexPDF.h"
#include "libComplexPDF/libComplexPDF.h"
#include "CacheIntegrator/CacheIntegrator.h"
#include "CacheIntegrator/DalitzAnalysisCore.h"
#include "CacheIntegrator/DalitzAnalysisNormCachedIntegral.h"
#include "CacheIntegrator/DalitzAnalysisRealCachedIntegral.h"
#include "CacheIntegrator/DalitzAnalysisImagCachedIntegral.h"

ClassImp(RooDalitzAnalysisCPV)

RooDalitzAnalysisCPV::RooDalitzAnalysisCPV(const char *name, const char *title,
                                           RooAbsReal& _mass_AB,
                                           RooAbsReal& _mass_BC,
                                           
                                           RooAbsCategory& _channel,
                                           
                                           RooAbsReal& _mass_1,
                                           RooAbsReal& _width_1,
                                           
                                           RooAbsReal& _mass_2,
                                           RooAbsReal& _width_2,
                                           
                                           RooAbsReal& _mass_3,
                                           RooAbsReal& _width_3,
                                           
                                           RooAbsReal& _mass_4,
                                           RooAbsReal& _width_4,
                                           
                                           RooAbsReal& _mass_5,
                                           RooAbsReal& _width_5,
                                           
                                           RooAbsReal& _mass_6,
                                           RooAbsReal& _width_6,
                                           
                                           RooAbsReal& _mass_7,
                                           RooAbsReal& _width_7,
                                           
                                           RooAbsReal& _amp_1,
                                           RooAbsReal& _phase_1,
                                           RooAbsReal& _amp_2,
                                           RooAbsReal& _phase_2,
                                           RooAbsReal& _amp_3,
                                           RooAbsReal& _phase_3,
                                           RooAbsReal& _amp_4,
                                           RooAbsReal& _phase_4,
                                           RooAbsReal& _amp_5,
                                           RooAbsReal& _phase_5,
                                           RooAbsReal& _amp_6,
                                           RooAbsReal& _phase_6,
                                           RooAbsReal& _amp_7,
                                           RooAbsReal& _phase_7,
                                           RooAbsReal& _amp_8,
                                           RooAbsReal& _phase_8,
                                           
                                           DAI_CC_parameters _s_cc_parameters,
                                           
                                           EFFICIENCY_FUNCTION _efficiency_function,
                                           
                                           DAI_PDG_constants _s_PDG,
                                           DAI_Dalitz_Model_parameters _s_DM_pars,
                                           DAI_CacheIntegrators_2D _s_2D) :
RooAbsPdf(name,title),
mass_AB("mass_AB","mass_AB",this,_mass_AB),
mass_BC("mass_BC","mass_BC",this,_mass_BC),
channel("channel","channel",this,_channel),
mass_1("mass_1","mass_1",this,_mass_1),
width_1("width_1","width_1",this,_width_1),
mass_2("mass_2","mass_2",this,_mass_2),
width_2("width_2","width_2",this,_width_2),
mass_3("mass_3","mass_3",this,_mass_3),
width_3("width_3","width_3",this,_width_3),
mass_4("mass_4","mass_4",this,_mass_4),
width_4("width_4","width_4",this,_width_4),
mass_5("mass_5","mass_5",this,_mass_5),
width_5("width_5","width_5",this,_width_5),
mass_6("mass_6","mass_6",this,_mass_6),
width_6("width_6","width_6",this,_width_6),
mass_7("mass_7","mass_7",this,_mass_7),
width_7("width_7","width_7",this,_width_7),
amp_1("amp_1","amp_1",this,_amp_1),
phase_1("phase_1","phase_1",this,_phase_1),
amp_2("amp_2","amp_2",this,_amp_2),
phase_2("phase_2","phase_2",this,_phase_2),
amp_3("amp_3","amp_3",this,_amp_3),
phase_3("phase_3","phase_3",this,_phase_3),
amp_4("amp_4","amp_4",this,_amp_4),
phase_4("phase_4","phase_4",this,_phase_4),
amp_5("amp_5","amp_5",this,_amp_5),
phase_5("phase_5","phase_5",this,_phase_5),
amp_6("amp_6","amp_6",this,_amp_6),
phase_6("phase_6","phase_6",this,_phase_6),
amp_7("amp_7","amp_7",this,_amp_7),
phase_7("phase_7","phase_7",this,_phase_7),
amp_8("amp_8","amp_8",this,_amp_8),
phase_8("phase_8","phase_8",this,_phase_8),
amp_1_CC("amp_1_CC","amp_1_CC",this,*_s_cc_parameters._amp_1_CC),
phase_1_CC("phase_1_CC","phase_1_CC",this,*_s_cc_parameters._phase_1_CC),
amp_2_CC("amp_2_CC","amp_2_CC",this,*_s_cc_parameters._amp_2_CC),
phase_2_CC("phase_2_CC","phase_2_CC",this,*_s_cc_parameters._phase_2_CC),
amp_3_CC("amp_3_CC","amp_3_CC",this,*_s_cc_parameters._amp_3_CC),
phase_3_CC("phase_3_CC","phase_3_CC",this,*_s_cc_parameters._phase_3_CC),
amp_4_CC("amp_4_CC","amp_4_CC",this,*_s_cc_parameters._amp_4_CC),
phase_4_CC("phase_4_CC","phase_4_CC",this,*_s_cc_parameters._phase_4_CC),
amp_5_CC("amp_5_CC","amp_5_CC",this,*_s_cc_parameters._amp_5_CC),
phase_5_CC("phase_5_CC","phase_5_CC",this,*_s_cc_parameters._phase_5_CC),
amp_6_CC("amp_6_CC","amp_6_CC",this,*_s_cc_parameters._amp_6_CC),
phase_6_CC("phase_6_CC","phase_6_CC",this,*_s_cc_parameters._phase_6_CC),
amp_7_CC("amp_7_CC","amp_7_CC",this,*_s_cc_parameters._amp_7_CC),
phase_7_CC("phase_7_CC","phase_7_CC",this,*_s_cc_parameters._phase_7_CC),
amp_8_CC("amp_8_CC","amp_8_CC",this,*_s_cc_parameters._amp_8_CC),
phase_8_CC("phase_8_CC","phase_8_CC",this,*_s_cc_parameters._phase_8_CC),
m_Pi0(_s_PDG.m_Pi0),
m_Pi(_s_PDG.m_Pi),
m_K(_s_PDG.m_K),
m_B0(_s_PDG.m_B0),
m_efficiency_function(_efficiency_function),
m_r_1(_s_DM_pars.m_r_1),
m_a_2(_s_DM_pars.m_a_2),
m_r_2(_s_DM_pars.m_r_2),
m_cutoff_2(_s_DM_pars.m_cutoff_2),
m_r_3(_s_DM_pars.m_r_3),
m_r_4(_s_DM_pars.m_r_4),
m_r_5(_s_DM_pars.m_r_5),
m_r_6(_s_DM_pars.m_r_6),
m_a_7(_s_DM_pars.m_a_7),
m_r_7(_s_DM_pars.m_r_7),
m_cutoff_7(_s_DM_pars.m_cutoff_7),
m_norm_cache_integrator(_s_2D.norm_cache_integrator),
m_real_cache_integrator(_s_2D.real_cache_integrator),
m_imag_cache_integrator(_s_2D.imag_cache_integrator){
}

RooDalitzAnalysisCPV::RooDalitzAnalysisCPV(const RooDalitzAnalysisCPV& other, const char* name) :
RooAbsPdf(other,name),
mass_AB("mass_AB",this,other.mass_AB),
mass_BC("mass_BC",this,other.mass_BC),
channel("channel",this,other.channel),
mass_1("mass_1",this,other.mass_1),
width_1("width_1",this,other.width_1),
mass_2("mass_2",this,other.mass_2),
width_2("width_2",this,other.width_2),
mass_3("mass_3",this,other.mass_3),
width_3("width_3",this,other.width_3),
mass_4("mass_4",this,other.mass_4),
width_4("width_4",this,other.width_4),
mass_5("mass_5",this,other.mass_5),
width_5("width_5",this,other.width_5),
mass_6("mass_6",this,other.mass_6),
width_6("width_6",this,other.width_6),
mass_7("mass_7",this,other.mass_7),
width_7("width_7",this,other.width_7),
amp_1("amp_1",this,other.amp_1),
phase_1("phase_1",this,other.phase_1),
amp_2("amp_2",this,other.amp_2),
phase_2("phase_2",this,other.phase_2),
amp_3("amp_3",this,other.amp_3),
phase_3("phase_3",this,other.phase_3),
amp_4("amp_4",this,other.amp_4),
phase_4("phase_4",this,other.phase_4),
amp_5("amp_5",this,other.amp_5),
phase_5("phase_5",this,other.phase_5),
amp_6("amp_6",this,other.amp_6),
phase_6("phase_6",this,other.phase_6),
amp_7("amp_7",this,other.amp_7),
phase_7("phase_7",this,other.phase_7),
amp_8("amp_8",this,other.amp_8),
phase_8("phase_8",this,other.phase_8),
amp_1_CC("amp_1_CC",this,other.amp_1_CC),
phase_1_CC("phase_1_CC",this,other.phase_1_CC),
amp_2_CC("amp_2_CC",this,other.amp_2_CC),
phase_2_CC("phase_2_CC",this,other.phase_2_CC),
amp_3_CC("amp_3_CC",this,other.amp_3_CC),
phase_3_CC("phase_3_CC",this,other.phase_3_CC),
amp_4_CC("amp_4_CC",this,other.amp_4_CC),
phase_4_CC("phase_4_CC",this,other.phase_4_CC),
amp_5_CC("amp_5_CC",this,other.amp_5_CC),
phase_5_CC("phase_5_CC",this,other.phase_5_CC),
amp_6_CC("amp_6_CC",this,other.amp_6_CC),
phase_6_CC("phase_6_CC",this,other.phase_6_CC),
amp_7_CC("amp_7_CC",this,other.amp_7_CC),
phase_7_CC("phase_7_CC",this,other.phase_7_CC),
amp_8_CC("amp_8_CC",this,other.amp_8_CC),
phase_8_CC("phase_8_CC",this,other.phase_8_CC),
m_Pi0(other.m_Pi0),
m_Pi(other.m_Pi),
m_K(other.m_K),
m_B0(other.m_B0),
m_efficiency_function(other.m_efficiency_function),
m_r_1(other.m_r_1),
m_a_2(other.m_a_2),
m_r_2(other.m_r_2),
m_cutoff_2(other.m_cutoff_2),
m_r_3(other.m_r_3),
m_r_4(other.m_r_4),
m_r_5(other.m_r_5),
m_r_6(other.m_r_6),
m_a_7(other.m_a_7),
m_r_7(other.m_r_7),
m_cutoff_7(other.m_cutoff_7),
m_norm_cache_integrator(other.m_norm_cache_integrator),
m_real_cache_integrator(other.m_real_cache_integrator),
m_imag_cache_integrator(other.m_imag_cache_integrator){
}

Double_t RooDalitzAnalysisCPV::evaluate() const {
    
    double MAB = std::sqrt(mass_AB);
    double MBC = std::sqrt(mass_BC);
    
    if(ComplexPDF::InsideDalitzLimits(MAB,MBC,m_B0,m_Pi0,m_Pi,m_K)){
        
        std::vector<std::complex<double> > A; A.reserve(8);
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::CA, ComplexPDF::AB, mass_1, width_1, m_r_1, 1, m_B0, m_Pi0, m_Pi, m_K));//K*+
        A.push_back(ComplexPDF::GetLASSMatrixElement(MAB, MBC, ComplexPDF::CA, mass_2, width_2, m_a_2, m_r_2, m_cutoff_2, m_B0, m_Pi0, m_Pi, m_K)); //K*(1430)+ (Kpi S-wave)
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::AB, ComplexPDF::BC, mass_3, width_3, m_r_3, 1, m_B0, m_Pi0, m_Pi, m_K)); //rho(770)-
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::AB, ComplexPDF::BC, mass_4, width_4, m_r_4, 1, m_B0, m_Pi0, m_Pi, m_K)); //rho(2S)(1450)-
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::AB, ComplexPDF::BC, mass_5, width_5, m_r_5, 1, m_B0, m_Pi0, m_Pi, m_K)); //rho(3S)(1700)-
        A.push_back(ComplexPDF::GetBreitWignerMatrixElement(MAB, MBC, ComplexPDF::BC, ComplexPDF::CA, mass_6, width_6, m_r_6, 1, m_B0, m_Pi0, m_Pi, m_K));//K*(892)0
        A.push_back(ComplexPDF::GetLASSMatrixElement(MAB, MBC, ComplexPDF::BC, mass_7, width_7, m_a_7, m_r_7, m_cutoff_7, m_B0, m_Pi0, m_Pi, m_K)); //K*(1430)0 (Kpi S-wave)
        A.push_back(ComplexPDF::DalitzPhaseSpaceAmplitude(MAB,MBC)); //Non-Resonant
        
        double acceptance = GetEff(mass_AB, mass_BC, m_efficiency_function);
        
        if(0 == channel) { // state C
            std::vector<std::complex<double> > a; a.reserve(8);
            a.push_back(std::polar((double)amp_1,(double)phase_1));
            a.push_back(std::polar((double)amp_2,(double)phase_2));
            a.push_back(std::polar((double)amp_3,(double)phase_3));
            a.push_back(std::polar((double)amp_4,(double)phase_4));
            a.push_back(std::polar((double)amp_5,(double)phase_5));
            a.push_back(std::polar((double)amp_6,(double)phase_6));
            a.push_back(std::polar((double)amp_7,(double)phase_7));
            a.push_back(std::polar((double)amp_8,(double)phase_8));
            
            std::complex<double> amplitude(0,0);
            for (unsigned int i=0; i<8; i++) {
                if (A[i]!=A[i]) {
                    std::cerr << "ERROR: Matrix element for amplitude " <<i+1<<" is NAN!!!"<< std::endl;
                    std::exit(EXIT_FAILURE);
                }else{
                    amplitude += a[i]*A[i];
                }
            }
            
            return acceptance * std::norm(amplitude);
            
        } else if (1 == channel) { // state CC
            std::vector<std::complex<double> > a; a.reserve(8);
            a.push_back(std::polar((double)amp_1_CC,(double)phase_1_CC));
            a.push_back(std::polar((double)amp_2_CC,(double)phase_2_CC));
            a.push_back(std::polar((double)amp_3_CC,(double)phase_3_CC));
            a.push_back(std::polar((double)amp_4_CC,(double)phase_4_CC));
            a.push_back(std::polar((double)amp_5_CC,(double)phase_5_CC));
            a.push_back(std::polar((double)amp_6_CC,(double)phase_6_CC));
            a.push_back(std::polar((double)amp_7_CC,(double)phase_7_CC));
            a.push_back(std::polar((double)amp_8_CC,(double)phase_8_CC));
            
            std::complex<double> amplitude(0,0);
            for (unsigned int i=0; i<8; i++) {
                if (A[i]!=A[i]) {
                    std::cerr << "ERROR: Matrix element for amplitude " <<i+1<<" is NAN!!!"<< std::endl;
                    std::exit(EXIT_FAILURE);
                }else{
                    amplitude += a[i]*A[i];
                }
            }
            
            return acceptance * std::norm(amplitude);
            
        } else {
            std::cerr << "ERROR: Unsupported channel type channel =" << channel << " in RooDalitzAnalysisCPV::evaluatel(...) --> Return 1.0" << std::endl;
            return 1.0;
        }
    } else {
        return 0.0;
    }
    
    
    
}

Int_t RooDalitzAnalysisCPV::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
    if (matchArgs(allVars, analVars, mass_AB, mass_BC))
		return 1;
	//std::cerr << "INFO: Unsupported analytical integral was requested in RooDalitzAnalysisCPV::getAnalyticalIntegral(...) " <<
	//		"--> Numeric integration will be used." <<  std::endl;
	return 0;
}

Double_t RooDalitzAnalysisCPV::analyticalIntegral(Int_t code, const char* rangeName ) const {
	return analyticalIntegralAndAsymmetry(code,rangeName).first;
}

Double_t RooDalitzAnalysisCPV::getAsymmetry(const char* rangeName ) const {
	return analyticalIntegralAndAsymmetry(1,rangeName).second;
}

std::pair<Double_t,Double_t> RooDalitzAnalysisCPV::analyticalIntegralAndAsymmetry(Int_t code, const char* rangeName ) const {
    
	// index values regarding which ressonance pair we use
    const int N_RES = 8 ;
    
	const double J_values[8]      = {1, 2, 3, 4, 5, 6, 7, 8};
	// complex weights
	const double amps[8]  = {amp_1,  amp_2,  amp_3,  amp_4,  amp_5,  amp_6,  amp_7, amp_8};
	const double phase[8] = {phase_1, phase_2, phase_3, phase_4, phase_5, phase_6, phase_7, phase_8};
    // complex weights CC
	const double amps_CC[8]  = {amp_1_CC,  amp_2_CC,  amp_3_CC,  amp_4_CC,  amp_5_CC,  amp_6_CC,  amp_7_CC, amp_8_CC};
	const double phase_CC[8] = {phase_1_CC, phase_2_CC, phase_3_CC, phase_4_CC, phase_5_CC, phase_6_CC, phase_7_CC, phase_8_CC};
    

 	// parameters index 0-30 are same for all integrals
	// index 31 is the acceptance function used
	std::vector<double> parameters;
	parameters.reserve(33);
	parameters.assign(32,0);
	// variable parameters (will be set in for loop below)
	parameters[0] = 0; // index of resonance
	parameters[1] = 0; // index of charged conjugate resonance
	// constant parameters for resonances
    parameters[2] = mass_1;
    parameters[3] = width_1;
    parameters[4] = m_r_1;
    parameters[5] = mass_2;
    parameters[6] = width_2;
    parameters[7] = m_a_2;
    parameters[8] = m_r_2;
    parameters[9] = m_cutoff_2;
    parameters[10] = mass_3;
    parameters[11] = width_3;
    parameters[12] = m_r_3;
    parameters[13] = mass_4;
    parameters[14] = width_4;
    parameters[15] = m_r_4;
    parameters[16] = mass_5;
    parameters[17] = width_5;
    parameters[18] = m_r_5;
    parameters[19] = mass_6;
    parameters[20] = width_6;
    parameters[21] = m_r_6;
    parameters[22] = mass_7;
    parameters[23] = width_7;
    parameters[24] = m_a_7;
    parameters[25] = m_r_7;
    parameters[26] = m_cutoff_7;
	// constant parameters
	parameters[27] = m_B0;
	parameters[28] = m_Pi0;
	parameters[29] = m_Pi;
	parameters[30] = m_K;
	// acceptance function
	parameters[31] = m_efficiency_function;
    
    if (code == 1) {
		std::vector<std::pair<double,double> > limits; limits.reserve(2);
		limits.push_back(std::make_pair(mass_AB.min(rangeName),mass_AB.max(rangeName)));
		limits.push_back(std::make_pair(mass_BC.min(rangeName),mass_BC.max(rangeName)));
        // swap limits if necessary
        for(unsigned int i = 0; i < limits.size(); ++i) {
            if(limits[i].first > limits[i].second) {
                std::swap(limits[i].first, limits[i].second);
            }
        }
        
        // matrix element
        double M = 0;
        double M_CC = 0;
		// calc each of the 64 terms (some need to be recalculated probably, some are done and fast)
        for(unsigned int i = 0; i < N_RES; ++i) {
            for(unsigned int j = 0; j < N_RES; ++j) {
                // setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = J_values[j];
                // switch between the three different types of integrals
                if(i==j) { // integral |A_i|^2
                    double integral = m_norm_cache_integrator->GetIntegral(limits,parameters);
                    M += amps[i]*amps[j]*integral;
                    M_CC += amps_CC[i]*amps_CC[j]*integral;
                } else if (i < j) { // integral Re(A_i A_j*)
                    double integral = m_real_cache_integrator->GetIntegral(limits,parameters);
                    M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*integral;
                    M_CC += 2*amps_CC[i]*amps_CC[j]*std::cos(phase_CC[i]-phase_CC[j])*integral;
                } else if (i > j) { // integral Im(A_i A_j*)
                    // flip i and j components, as always A_j needs to be cc
                    std::swap(parameters[0],parameters[1]);
                    double integral = m_imag_cache_integrator->GetIntegral(limits,parameters);
                    M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*integral;
                    M_CC -= 2*amps_CC[i]*amps_CC[j]*std::sin(phase_CC[j]-phase_CC[i])*integral;
                }
            }
        }
        return std::make_pair((M+M_CC)/2.0,(M-M_CC)/(M+M_CC));
    }
    
    std::cerr << "ERROR: Unsupported analytical integral code=" << code << " in RooDalitzAnalysisCPV::analyticalIntegral(...) " <<
    "--> Return 0" << std::endl;
    return std::make_pair(0,0);
    
}

