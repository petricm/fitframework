/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooDalitzDelaunay.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include <complex>
#include "libComplexPDF/libComplexPDF.h"

ClassImp(RooDalitzDelaunay) 

RooDalitzDelaunay::RooDalitzDelaunay(const char *name, const char *title,
		RooAbsReal& _m12,
		RooAbsReal& _m23,
        TGraph2D *_graph,
		double _mM,
        double _m1,
		double _m2,
		double _m3) :
		RooAbsPdf(name,title),
		m12("m12","m12",this,_m12),
		m23("m23","m23",this,_m23),
        graph(_graph),
		mM(_mM),
        m1(_m1),
		m2(_m2),
		m3(_m3) {
}

RooDalitzDelaunay::RooDalitzDelaunay(const RooDalitzDelaunay& other, const char* name) :
	   RooAbsPdf(other,name),
	   m12("m12",this,other.m12),
	   m23("m23",this,other.m23),
       graph(other.graph),
	   mM(other.mM),
       m1(other.m1),
	   m2(other.m2),
	   m3(other.m3) {
}

Double_t RooDalitzDelaunay::evaluate() const {
	double sqrt_m12 = std::sqrt(m12);
	double sqrt_m23 = std::sqrt(m23);
	if(ComplexPDF::InsideDalitzLimits(sqrt_m12,sqrt_m23,mM,m1,m2,m3)) {
		return graph->Interpolate(m12,m23);
	} else {
		return 1.0e-05;
	}
}


Int_t RooDalitzDelaunay::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
	
    if (matchArgs(allVars, analVars, m12, m23)){
		return 1;
    }
	return 0;
}

Double_t RooDalitzDelaunay::analyticalIntegral(Int_t code, const char* rangeName ) const {
	
    if (code==1) {
        return 125420.0;
        //84.3176; efficiency
    }
    
    return 0.0;
    
}







