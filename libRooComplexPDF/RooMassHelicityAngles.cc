/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooMassHelicityAngles.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "libComplexPDF/libComplexPDF.h"
#include "CacheIntegrator/CacheIntegrator.h"
#include "CacheIntegrator/MassHelicityAnglesCore.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_phi_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_phi_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_phi_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_m_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_m_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_m_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_m_phi_th2.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_m_phi_th2.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_m_phi_th2.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_m_phi_th1.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_m_phi_th1.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_m_phi_th1.h"

// include efficiency histogram for HIST_4D
#include "efficiency_histogram_4D.cc"

// default values and errors for PRODUCT_4D
double EffParam[7]    = {-0.053, 0.135, 0.204, -0.203, -0.054, 0.060, 0.330};
double EffParamErr[7] = { 0.019, 0.044, 0.025,  0.023,  0.008, 0.016, 0.002};

double GetEff(const double m, const double phi, const double th1, const double th2, ACCEPTANCE_FUNCTION value) {
	double cos_th1 = std::cos(th1);
	switch (value) {
	case UNIFORM:
		return 1.0;
	case CUT_TH1:
		if(cos_th1 < 0.75)
			return 1.0;
		else
			return 0.0;
	case PRODUCT_4D:
		if(cos_th1 < 0.75) {
			//double eff_m = -0.053*m*m + 0.135*m + 0.204;
			double eff_m = EffParam[0]*m*m + EffParam[1]*m + EffParam[2];
			double cos_th1_s = cos_th1*cos_th1;
			//double eff_th1 = -0.203*cos_th1_s*cos_th1_s - 0.054*cos_th1_s*cos_th1 + 0.060*cos_th1_s + 0.330;
			double eff_th1 = EffParam[3]*cos_th1_s*cos_th1_s + EffParam[4]*cos_th1_s*cos_th1 + EffParam[5]*cos_th1_s + EffParam[6];
			// th2 and phi have flat acceptance and we therefore ignore them in the product
			return eff_m*eff_th1;
		} else {
			return 0.0;
		}
	case HIST_4D:
		if(cos_th1 < 0.75) {
			double cos_th2 = std::cos(th2);
			// index[mass_kpi][hel_phi][hel_th1][hel_th2]
			return hist_eff[GetBin_mass_kpi(m)][GetBin_hel_phi(phi)][GetBin_hel_th1(cos_th1)][GetBin_hel_th2(cos_th2)];
		} else {
			return 0.0;
		}
	default:
		std::cerr << "ERROR: Unknown acceptance function code " << value << " in GetEff(...)" << std::endl;
		break;
	}
	return 1.0;
}

ClassImp(RooMassHelicityAngles) 

RooMassHelicityAngles::RooMassHelicityAngles(const char *name, const char *title,
		RooAbsReal& _m,
		RooAbsReal& _phi,
		RooAbsReal& _cos_th1,
		RooAbsReal& _cos_th2,
		RooAbsReal& _mass_0,
		RooAbsReal& _width_0,
		RooAbsReal& _a,
		RooAbsReal& _b,
		RooAbsReal& _mass_1,
		RooAbsReal& _width_1,
		RooAbsReal& _r_1,
		RooAbsReal& _mass_2,
		RooAbsReal& _width_2,
		RooAbsReal& _r_2,
		RooAbsReal& _amp_00,
		RooAbsReal& _phase_00,
		RooAbsReal& _amp_1m,
		RooAbsReal& _phase_1m,
		RooAbsReal& _amp_10,
		RooAbsReal& _phase_10,
		RooAbsReal& _amp_1p,
		RooAbsReal& _phase_1p,
		RooAbsReal& _amp_2m,
		RooAbsReal& _phase_2m,
		RooAbsReal& _amp_20,
		RooAbsReal& _phase_20,
		RooAbsReal& _amp_2p,
		RooAbsReal& _phase_2p,
		ACCEPTANCE_FUNCTION _acceptance_function,
		MHI_PDG_constants _s_PDG,
		MHI_CacheIntegrators_4D _s_4D,
		MHI_CacheIntegrators_3D_phi_th1_th2 _s_3D_phi_th1_th2,
		MHI_CacheIntegrators_3D_m_th1_th2 _s_3D_m_th1_th2,
		MHI_CacheIntegrators_3D_m_phi_th2 _s_3D_m_phi_th2,
		MHI_CacheIntegrators_3D_m_phi_th1 _s_3D_m_phi_th1) :
		RooAbsPdf(name,title),
		m("m","m",this,_m),
		phi("phi","phi",this,_phi),
		cos_th1("cos_th1","cos_th1",this,_cos_th1),
		cos_th2("cos_th2","cos_th2",this,_cos_th2),
		mass_0("mass_0","mass_0",this,_mass_0),
		width_0("width_0","width_0",this,_width_0),
		a("a","a",this,_a),
		b("b","b",this,_b),
		mass_1("mass_1","mass_1",this,_mass_1),
		width_1("width_1","width_1",this,_width_1),
		r_1("r_1","r_1",this,_r_1),
		mass_2("mass_2","mass_2",this,_mass_2),
		width_2("width_2","width_2",this,_width_2),
		r_2("r_2","r_2",this,_r_2),
		amp_00("amp_00","amp_00",this,_amp_00),
		phase_00("phase_00","phase_00",this,_phase_00),
		amp_1m("amp_1m","amp_1m",this,_amp_1m),
		phase_1m("phase_1m","phase_1m",this,_phase_1m),
		amp_10("amp_10","amp_10",this,_amp_10),
		phase_10("phase_10","phase_10",this,_phase_10),
		amp_1p("amp_1p","amp_1p",this,_amp_1p),
		phase_1p("phase_1p","phase_1p",this,_phase_1p),
		amp_2m("amp_2m","amp_2m",this,_amp_2m),
		phase_2m("phase_2m","phase_2m",this,_phase_2m),
		amp_20("amp_20","amp_20",this,_amp_20),
		phase_20("phase_20","phase_20",this,_phase_20),
		amp_2p("amp_2p","amp_2p",this,_amp_2p),
		phase_2p("phase_2p","phase_2p",this,_phase_2p),
		m_Pi(_s_PDG.m_Pi),
		m_K(_s_PDG.m_K),
		m_Phi(_s_PDG.m_Phi),
		m_B0(_s_PDG.m_B0),
		m_acceptance_function(_acceptance_function),
		m_norm_cache_integrator(_s_4D.norm_cache_integrator),
		m_real_cache_integrator(_s_4D.real_cache_integrator),
		m_imag_cache_integrator(_s_4D.imag_cache_integrator),
		m_norm_cache_integrator_phi_th1_th2(_s_3D_phi_th1_th2.norm_cache_integrator_phi_th1_th2),
		m_real_cache_integrator_phi_th1_th2(_s_3D_phi_th1_th2.real_cache_integrator_phi_th1_th2),
		m_imag_cache_integrator_phi_th1_th2(_s_3D_phi_th1_th2.imag_cache_integrator_phi_th1_th2),
		m_norm_cache_integrator_m_th1_th2(_s_3D_m_th1_th2.norm_cache_integrator_m_th1_th2),
		m_real_cache_integrator_m_th1_th2(_s_3D_m_th1_th2.real_cache_integrator_m_th1_th2),
		m_imag_cache_integrator_m_th1_th2(_s_3D_m_th1_th2.imag_cache_integrator_m_th1_th2),
		m_norm_cache_integrator_m_phi_th2(_s_3D_m_phi_th2.norm_cache_integrator_m_phi_th2),
		m_real_cache_integrator_m_phi_th2(_s_3D_m_phi_th2.real_cache_integrator_m_phi_th2),
		m_imag_cache_integrator_m_phi_th2(_s_3D_m_phi_th2.imag_cache_integrator_m_phi_th2),
		m_norm_cache_integrator_m_phi_th1(_s_3D_m_phi_th1.norm_cache_integrator_m_phi_th1),
		m_real_cache_integrator_m_phi_th1(_s_3D_m_phi_th1.real_cache_integrator_m_phi_th1),
		m_imag_cache_integrator_m_phi_th1(_s_3D_m_phi_th1.imag_cache_integrator_m_phi_th1){
}

RooMassHelicityAngles::RooMassHelicityAngles(const RooMassHelicityAngles& other, const char* name) :
	   RooAbsPdf(other,name),
	   m("m",this,other.m),
	   phi("phi",this,other.phi),
	   cos_th1("cos_th1",this,other.cos_th1),
	   cos_th2("cos_th2",this,other.cos_th2),
	   mass_0("mass_0",this,other.mass_0),
	   width_0("width_0",this,other.width_0),
	   a("a",this,other.a),
	   b("b",this,other.b),
	   mass_1("mass_1",this,other.mass_1),
	   width_1("width_1",this,other.width_1),
	   r_1("r_1",this,other.r_1),
	   mass_2("mass_2",this,other.mass_2),
	   width_2("width_2",this,other.width_2),
	   r_2("r_2",this,other.r_2),
	   amp_00("amp_00",this,other.amp_00),
	   phase_00("phase_00",this,other.phase_00),
	   amp_1m("amp_1m",this,other.amp_1m),
	   phase_1m("phase_1m",this,other.phase_1m),
	   amp_10("amp_10",this,other.amp_10),
	   phase_10("phase_10",this,other.phase_10),
	   amp_1p("amp_1p",this,other.amp_1p),
	   phase_1p("phase_1p",this,other.phase_1p),
	   amp_2m("amp_2m",this,other.amp_2m),
	   phase_2m("phase_2m",this,other.phase_2m),
	   amp_20("amp_20",this,other.amp_20),
	   phase_20("phase_20",this,other.phase_20),
	   amp_2p("amp_2p",this,other.amp_2p),
	   phase_2p("phase_2p",this,other.phase_2p),
	   m_Pi(other.m_Pi),
	   m_K(other.m_K),
	   m_Phi(other.m_Phi),
	   m_B0(other.m_B0),
	   m_acceptance_function(other.m_acceptance_function),
	   m_norm_cache_integrator(other.m_norm_cache_integrator),
	   m_real_cache_integrator(other.m_real_cache_integrator),
	   m_imag_cache_integrator(other.m_imag_cache_integrator),
	   m_norm_cache_integrator_phi_th1_th2(other.m_norm_cache_integrator_phi_th1_th2),
	   m_real_cache_integrator_phi_th1_th2(other.m_real_cache_integrator_phi_th1_th2),
	   m_imag_cache_integrator_phi_th1_th2(other.m_imag_cache_integrator_phi_th1_th2),
	   m_norm_cache_integrator_m_th1_th2(other.m_norm_cache_integrator_m_th1_th2),
	   m_real_cache_integrator_m_th1_th2(other.m_real_cache_integrator_m_th1_th2),
	   m_imag_cache_integrator_m_th1_th2(other.m_imag_cache_integrator_m_th1_th2),
	   m_norm_cache_integrator_m_phi_th2(other.m_norm_cache_integrator_m_phi_th2),
	   m_real_cache_integrator_m_phi_th2(other.m_real_cache_integrator_m_phi_th2),
	   m_imag_cache_integrator_m_phi_th2(other.m_imag_cache_integrator_m_phi_th2),
	   m_norm_cache_integrator_m_phi_th1(other.m_norm_cache_integrator_m_phi_th1),
	   m_real_cache_integrator_m_phi_th1(other.m_real_cache_integrator_m_phi_th1),
	   m_imag_cache_integrator_m_phi_th1(other.m_imag_cache_integrator_m_phi_th1){
}

Double_t RooMassHelicityAngles::evaluate() const {
	// amplitude vectors J=0,1,2
	// Spin J=0 (only long.)
	std::vector<std::complex<double> > A_0; A_0.reserve(1);
	A_0.push_back(std::polar((double)amp_00,(double)phase_00));
	// Spin J=1 (lambda -1,0,1)
	std::vector<std::complex<double> > A_1; A_1.reserve(3);
	A_1.push_back(std::polar((double)amp_1m,(double)phase_1m));
	A_1.push_back(std::polar((double)amp_10,(double)phase_10));
	A_1.push_back(std::polar((double)amp_1p,(double)phase_1p));
	// Spin J=2 (lambda -1,0,1)
	std::vector<std::complex<double> > A_2; A_2.reserve(3);
	A_2.push_back(std::polar((double)amp_2m,(double)phase_2m));
	A_2.push_back(std::polar((double)amp_20,(double)phase_20));
	A_2.push_back(std::polar((double)amp_2p,(double)phase_2p));
	// calculate momentum in rest frame of resonances
	double q = ComplexPDF::CalculateMomentum(m,m_Pi,m_K);
	double q_0 = ComplexPDF::CalculateMomentum(mass_0,m_Pi,m_K);
	double q_1 = ComplexPDF::CalculateMomentum(mass_1,m_Pi,m_K);
	double q_2 = ComplexPDF::CalculateMomentum(mass_2,m_Pi,m_K);

	double acos_cos_th1 = std::acos(cos_th1);
	double acos_cos_th2 = std::acos(cos_th2);

	std::complex<double> lass = ComplexPDF::LASS(m,mass_0,width_0,a,b,q,q_0);
	std::complex<double> rbw_1 = ComplexPDF::RelativisticSpinBreitWigner(m,mass_1,width_1,r_1,1,q,q_1);
	std::complex<double> rbw_2 = ComplexPDF::RelativisticSpinBreitWigner(m,mass_2,width_2,r_2,2,q,q_2);
	std::complex<double> angular_0 = ComplexPDF::HelicityAngles(phi,acos_cos_th1,acos_cos_th2,0,1,A_0);
	std::complex<double> angular_1 = ComplexPDF::HelicityAngles(phi,acos_cos_th1,acos_cos_th2,1,1,A_1);
	std::complex<double> angular_2 = ComplexPDF::HelicityAngles(phi,acos_cos_th1,acos_cos_th2,2,1,A_2);

	// result amplitude
	std::complex<double> amplitude = angular_0 * lass + angular_1 * rbw_1 + angular_2 * rbw_2;
	// phase space factor
	double F = ComplexPDF::PhaseSpaceFactor(m,m_B0,m_Pi,m_K,m_Phi);
	// acceptance function
	double acceptance = GetEff(m,phi,acos_cos_th1,acos_cos_th2,m_acceptance_function);
	// return |A|^2
	return acceptance * std::norm(amplitude) * F;
}

Int_t RooMassHelicityAngles::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
	if (matchArgs(allVars, analVars, m, phi, cos_th1, cos_th2))
		return 5;
	if (matchArgs(allVars, analVars, phi, cos_th1, cos_th2))
		return 4;
	if (matchArgs(allVars, analVars, m, cos_th1, cos_th2))
		return 3;
	if (matchArgs(allVars, analVars, m, phi, cos_th2))
		return 2;
	if (matchArgs(allVars, analVars, m, phi, cos_th1))
		return 1;
	//std::cerr << "INFO: Unsupported analytical integral was requested in RooMassHelicityAngles::getAnalyticalIntegral(...) " <<
	//		"--> Numeric integration will be used." <<  std::endl;
	return 0;
}

Double_t RooMassHelicityAngles::analyticalIntegral(Int_t code, const char* rangeName ) const {
	// J and lambda values of each amplitude
	const double J_values[7]      = {0, 1,1,1, 2,2,2};
	const double lambda_values[7] = {0,-1,0,1,-1,0,1};
	// complex weights
	const double amps[7]  = {amp_00,  amp_1m,  amp_10,  amp_1p,  amp_2m,  amp_20,  amp_2p};
	const double phase[7] = {phase_00,phase_1m,phase_10,phase_1p,phase_2m,phase_20,phase_2p};

	// parameters index 0-17 are same for all integrals
	// index 18 is the acceptance function used
	// index 19 might be one of the variables
	std::vector<double> parameters;
	parameters.reserve(20);
	parameters.assign(19,0);
	// variable parameters (will be set in for loop below)
	parameters[0] = 0; // J
	parameters[1] = 0; // lambda
	parameters[2] = 0; // J_cc
	parameters[3] = 0; // lambda_cc
	// constant parameters for resonances
	parameters[4] = mass_0;
	parameters[5] = width_0;
	parameters[6] = a;
	parameters[7] = b;
	parameters[8] = mass_1;
	parameters[9] = width_1;
	parameters[10] = r_1;
	parameters[11] = mass_2;
	parameters[12] = width_2;
	parameters[13] = r_2;
	// constant parameters
	parameters[14] = m_B0;
	parameters[15] = m_Pi;
	parameters[16] = m_K;
	parameters[17] = m_Phi;
	// acceptance function
	parameters[18] = m_acceptance_function;

	if (code == 5) {
		std::vector<std::pair<double,double> > limits; limits.reserve(4);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 4) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(m);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_phi_th1_th2->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_phi_th1_th2->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_phi_th1_th2->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 3) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(phi);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_m_th1_th2->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_m_th1_th2->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_m_th1_th2->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 2) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(cos_th1);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_m_phi_th2->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_m_phi_th2->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_m_phi_th2->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 1) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(cos_th2);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_m_phi_th1->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_m_phi_th1->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_m_phi_th1->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	}
	std::cerr << "ERROR: Unsupported analytical integral code=" << code << " in RooMassHelicityAngles::analyticalIntegral(...) " <<
			"--> Return 0" << std::endl;
	return 0;
}

