/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooDalitzCubicPolynomialSymmetric.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include <complex>
#include "libComplexPDF/libComplexPDF.h"

ClassImp(RooDalitzCubicPolynomialSymmetric) 

RooDalitzCubicPolynomialSymmetric::RooDalitzCubicPolynomialSymmetric(const char *name, const char *title,
		RooAbsReal& _m12,
		RooAbsReal& _m23,
		RooAbsReal& _E_1,
		RooAbsReal& _E_2,
		RooAbsReal& _E_3,
		RooAbsReal& _E_xy,
		RooAbsReal& _E_xyn,
		double _m1,
		double _m2,
		double _m3,
		double _mM,
		double _m12_offset,
		double _m23_offset) :
		RooAbsPdf(name,title),
		m12("m12","m12",this,_m12),
		m23("m23","m23",this,_m23),
		E_1("E_1","E_1",this,_E_1),
		E_2("E_2","E_2",this,_E_2),
		E_3("E_3","E_3",this,_E_3),
		E_xy("E_xy","E_xy",this,_E_xy),
		E_xyn("E_xyn","E_xyn",this,_E_xyn),
		m1(_m1),
		m2(_m2),
		m3(_m3),
		mM(_mM),
		m12_offset(_m12_offset),
		m23_offset(_m23_offset) {
}

RooDalitzCubicPolynomialSymmetric::RooDalitzCubicPolynomialSymmetric(const RooDalitzCubicPolynomialSymmetric& other, const char* name) :
	   RooAbsPdf(other,name),
	   m12("m12",this,other.m12),
	   m23("m23",this,other.m23),
	   E_1("E_1",this,other.E_1),
	   E_2("E_2",this,other.E_2),
	   E_3("E_3",this,other.E_3),
	   E_xy("E_xy",this,other.E_xy),
	   E_xyn("E_xyn",this,other.E_xyn),
	   m1(other.m1),
	   m2(other.m2),
	   m3(other.m3),
	   mM(other.mM),
	   m12_offset(other.m12_offset),
	   m23_offset(other.m23_offset) {
}

Double_t RooDalitzCubicPolynomialSymmetric::evaluate() const {
	double sqrt_m12 = std::sqrt(m12);
	double sqrt_m23 = std::sqrt(m23);
	if(ComplexPDF::InsideDalitzLimits(sqrt_m12,sqrt_m23,mM,m1,m2,m3)) {
		return ComplexPDF::DalitzCubicPolynomialSymmetric(sqrt_m12,sqrt_m23,E_1,E_2,E_3,E_xy,E_xyn,m12_offset,m23_offset);
	} else {
		return 0.0;
	}
}
