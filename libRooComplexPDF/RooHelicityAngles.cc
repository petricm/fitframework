/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooHelicityAngles.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h"
#include "libComplexPDF/libComplexPDF.h"

ClassImp(RooHelicityAngles) 

RooHelicityAngles::RooHelicityAngles(const char *name, const char *title,
		RooAbsReal& _phi,
		RooAbsReal& _cos_th1,
		RooAbsReal& _cos_th2,
		RooAbsReal& _J1,
		RooAbsReal& _J2,
		RooAbsReal& _amp_m,
		RooAbsReal& _phase_m,
		RooAbsReal& _amp_0,
		RooAbsReal& _phase_0,
		RooAbsReal& _amp_p,
		RooAbsReal& _phase_p) :
		RooAbsPdf(name,title),
		phi("phi","phi",this,_phi),
		cos_th1("cos_th1","cos_th1",this,_cos_th1),
		cos_th2("cos_th2","cos_th2",this,_cos_th2),
		J1("J1","J1",this,_J1),
		J2("J2","J2",this,_J2),
		amp_m("amp_m","amp_m",this,_amp_m),
		phase_m("phase_m","phase_m",this,_phase_m),
		amp_0("amp_0","amp_0",this,_amp_0),
		phase_0("phase_0","phase_0",this,_phase_0),
		amp_p("amp_p","amp_p",this,_amp_p),
		phase_p("phase_p","phase_p",this,_phase_p) {
}

RooHelicityAngles::RooHelicityAngles(const RooHelicityAngles& other, const char* name) :
	   RooAbsPdf(other,name),
	   phi("phi",this,other.phi),
	   cos_th1("cos_th1",this,other.cos_th1),
	   cos_th2("cos_th2",this,other.cos_th2),
	   J1("J1",this,other.J1),
	   J2("J2",this,other.J2),
	   amp_m("amp_m",this,other.amp_m),
	   phase_m("phase_m",this,other.phase_m),
	   amp_0("amp_0",this,other.amp_0),
	   phase_0("phase_0",this,other.phase_0),
	   amp_p("amp_p",this,other.amp_p),
	   phase_p("phase_p",this,other.phase_p) {
}

Double_t RooHelicityAngles::evaluate() const {
	// create amplitudes vector, order is important and lambda = -1,0,1
	std::vector<std::complex<double> > A;
	if(std::min((unsigned int)J1, (unsigned int)J2) == 1)
		A.push_back(std::polar((double)amp_m,(double)phase_m));
	A.push_back(std::polar((double)amp_0,(double)phase_0));
	if(std::min((unsigned int)J1, (unsigned int)J2) == 1)
		A.push_back(std::polar((double)amp_p,(double)phase_p));
	// calc angular amplitude
	std::complex<double> amplitude = ComplexPDF::HelicityAngles(phi,std::acos(cos_th1),std::acos(cos_th2),(unsigned int)J1,(unsigned int)J2,A);
	return std::norm(amplitude);
}
