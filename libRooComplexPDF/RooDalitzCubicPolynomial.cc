/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooDalitzCubicPolynomial.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include <complex>
#include "libComplexPDF/libComplexPDF.h"

ClassImp(RooDalitzCubicPolynomial) 

RooDalitzCubicPolynomial::RooDalitzCubicPolynomial(const char *name, const char *title,
		RooAbsReal& _m12,
		RooAbsReal& _m23,
		RooAbsReal& _E_x,
		RooAbsReal& _E_y,
		RooAbsReal& _E_xx,
		RooAbsReal& _E_xy,
		RooAbsReal& _E_yy,
		RooAbsReal& _E_xxx,
		RooAbsReal& _E_xxy,
		RooAbsReal& _E_xyy,
		RooAbsReal& _E_yyy,
		double _m1,
		double _m2,
		double _m3,
		double _mM,
		double _m12_offset,
		double _m23_offset) :
		RooAbsPdf(name,title),
		m12("m12","m12",this,_m12),
		m23("m23","m23",this,_m23),
		E_x("E_x","E_x",this,_E_x),
		E_y("E_y","E_y",this,_E_y),
		E_xx("E_xx","E_xx",this,_E_xx),
		E_xy("E_xy","E_xy",this,_E_xy),
		E_yy("E_yy","E_yy",this,_E_yy),
		E_xxx("E_xxx","E_xxx",this,_E_xxx),
		E_xxy("E_xxy","E_xxy",this,_E_xxy),
		E_xyy("E_xyy","E_xyy",this,_E_xyy),
		E_yyy("E_yyy","E_yyy",this,_E_yyy),
		m1(_m1),
		m2(_m2),
		m3(_m3),
		mM(_mM),
		m12_offset(_m12_offset),
		m23_offset(_m23_offset) {
}

RooDalitzCubicPolynomial::RooDalitzCubicPolynomial(const RooDalitzCubicPolynomial& other, const char* name) :
	   RooAbsPdf(other,name),
	   m12("m12",this,other.m12),
	   m23("m23",this,other.m23),
	   E_x("E_x",this,other.E_x),
	   E_y("E_y",this,other.E_y),
	   E_xx("E_xx",this,other.E_xx),
	   E_xy("E_xy",this,other.E_xy),
	   E_yy("E_yy",this,other.E_yy),
	   E_xxx("E_xxx",this,other.E_xxx),
	   E_xxy("E_xxy",this,other.E_xxy),
	   E_xyy("E_xyy",this,other.E_xyy),
	   E_yyy("E_yyy",this,other.E_yyy),
	   m1(other.m1),
	   m2(other.m2),
	   m3(other.m3),
	   mM(other.mM),
	   m12_offset(other.m12_offset),
	   m23_offset(other.m23_offset) {
}

Double_t RooDalitzCubicPolynomial::evaluate() const {
	double sqrt_m12 = std::sqrt(m12);
	double sqrt_m23 = std::sqrt(m23);
	if(ComplexPDF::InsideDalitzLimits(sqrt_m12,sqrt_m23,mM,m1,m2,m3)) {
		return ComplexPDF::DalitzCubicPolynomial(sqrt_m12,sqrt_m23,E_x,E_y,E_xx,E_xy,E_yy,E_xxx,E_xxy,E_xyy,E_yyy,m12_offset,m23_offset);
	} else {
		return 1.0e-5;
	}
}


Int_t RooDalitzCubicPolynomial::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
	
    //if (matchArgs(allVars, analVars, m12, m23))
	//	return 1;
	//std::cerr << "INFO: Unsupported analytical integral was requested in RooDalitzAnalysis::getAnalyticalIntegral(...) " <<
	//		"--> Numeric integration will be used." <<  std::endl;
	return 0;
}

Double_t RooDalitzCubicPolynomial::adaptiveSimpsonsAux(double x, double a, double b, double epsilon, double S, double fa, double fb, double fc, int bottom) const {
    Double_t c = (a + b)/2, h = b - a;
    Double_t d = (a + c)/2, e = (c + b)/2;
    
    Double_t fd = ComplexPDF::DalitzCubicPolynomial(std::sqrt(x),std::sqrt(d),E_x,E_y,E_xx,E_xy,E_yy,E_xxx,E_xxy,E_xyy,E_yyy,m12_offset,m23_offset);
    Double_t fe = ComplexPDF::DalitzCubicPolynomial(std::sqrt(x),std::sqrt(e),E_x,E_y,E_xx,E_xy,E_yy,E_xxx,E_xxy,E_xyy,E_yyy,m12_offset,m23_offset);
    
    
    Double_t Sleft = (h/12)*(fa + 4*fd + fc);
    Double_t Sright = (h/12)*(fc + 4*fe + fb);
    Double_t S2 = Sleft + Sright;
    
    if (bottom <= 0 || fabs(S2 - S) <= 15*epsilon){
        return S2 + (S2 - S)/15;
    }
    return adaptiveSimpsonsAux(x, a, c, epsilon/2, Sleft,  fa, fc, fd, bottom-1) + adaptiveSimpsonsAux(x, c, b, epsilon/2, Sright, fc, fb, fe, bottom-1);
}

Double_t RooDalitzCubicPolynomial::adaptiveSimpsons(double x, double a, double b, double epsilon, int maxRecursionDepth) const {
    Double_t c = (a + b)/2;
    Double_t h = b - a;
    Double_t fa = ComplexPDF::DalitzCubicPolynomial(std::sqrt(x),std::sqrt(a),E_x,E_y,E_xx,E_xy,E_yy,E_xxx,E_xxy,E_xyy,E_yyy,m12_offset,m23_offset);
    Double_t fb = ComplexPDF::DalitzCubicPolynomial(std::sqrt(x),std::sqrt(b),E_x,E_y,E_xx,E_xy,E_yy,E_xxx,E_xxy,E_xyy,E_yyy,m12_offset,m23_offset);
    Double_t fc = ComplexPDF::DalitzCubicPolynomial(std::sqrt(x),std::sqrt(c),E_x,E_y,E_xx,E_xy,E_yy,E_xxx,E_xxy,E_xyy,E_yyy,m12_offset,m23_offset);
    Double_t S = (h/6)*(fa + 4*fc + fb);
    return adaptiveSimpsonsAux(x, a, b, epsilon, S, fa, fb, fc, maxRecursionDepth);
}

Double_t RooDalitzCubicPolynomial::analyticalIntegral(Int_t code, const char* rangeName ) const {
    
    int n_slices = 500;
    
	if (code == 1) {
        
        double x_min = (m1+m2)*(m1+m2);
        double x_max = (mM-m3)*(mM-m3);
        double dx = (x_max-x_min)/(double)n_slices;
        double x=0;
        Double_t integral = 0;
        double m23_max_2;
        double m23_min_2;
        double eps = 0.1/(double)n_slices;
        
        for (int i = 1; i<n_slices; i++) {
            x = x_min + i *dx;
            ComplexPDF::DalitzLimits(std::sqrt(x), mM, m1, m2, m3, m23_max_2, m23_min_2);
            
            if (std::isnan(m23_max_2) || std::isnan(m23_min_2)) {
                std::cerr << "Integral boundaries in RooDalitzCubicPolynomial::analyticalIntegral(...) are ("<< m23_min_2 <<", "<<m23_max_2 <<") at x = "<<x<< std::endl;
            }
            
            integral+=adaptiveSimpsons(x, m23_min_2, m23_max_2, eps, 10)*dx;
        }

        if (std::isnan(integral)) {
            std::cerr << "Intergral in RooDalitzCubicPolynomial::analyticalIntegral(...) is"<< integral << std::endl;
            return 1;
        }
        return integral;
        
	}
	std::cerr << "ERROR: Unsupported analytical integral code=" << code << " in RooDalitzCubicPolynomial::analyticalIntegral(...) " <<
    "--> Return 0" << std::endl;
	return 0;
}



