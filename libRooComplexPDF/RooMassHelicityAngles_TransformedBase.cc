/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooMassHelicityAngles_TransformedBase.h"
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "libComplexPDF/libComplexPDF.h"
#include "CacheIntegrator/CacheIntegrator.h"
#include "CacheIntegrator/MassHelicityAnglesCore.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_phi_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_phi_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_phi_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_m_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_m_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_m_th1_th2.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_m_phi_th2.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_m_phi_th2.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_m_phi_th2.h"
#include "CacheIntegrator/MassHelicityAnglesNormCachedIntegral_m_phi_th1.h"
#include "CacheIntegrator/MassHelicityAnglesRealCachedIntegral_m_phi_th1.h"
#include "CacheIntegrator/MassHelicityAnglesImagCachedIntegral_m_phi_th1.h"

ClassImp(RooMassHelicityAngles_TransformedBase)

RooMassHelicityAngles_TransformedBase::RooMassHelicityAngles_TransformedBase(const char *name, const char *title,
		RooAbsReal& _m,
		RooAbsReal& _phi,
		RooAbsReal& _cos_th1,
		RooAbsReal& _cos_th2,
		RooAbsReal& _mass_0,
		RooAbsReal& _width_0,
		RooAbsReal& _a,
		RooAbsReal& _b,
		RooAbsReal& _mass_1,
		RooAbsReal& _width_1,
		RooAbsReal& _r_1,
		RooAbsReal& _mass_2,
		RooAbsReal& _width_2,
		RooAbsReal& _r_2,
		RooAbsReal& _amp_00,
		RooAbsReal& _phase_00,
		RooAbsReal& _amp_10,
		RooAbsReal& _phase_10,
		RooAbsReal& _amp_1para,
		RooAbsReal& _phase_1para,
		RooAbsReal& _amp_1perp,
		RooAbsReal& _phase_1perp,
		RooAbsReal& _amp_20,
		RooAbsReal& _phase_20,
		RooAbsReal& _amp_2para,
		RooAbsReal& _phase_2para,
		RooAbsReal& _amp_2perp,
		RooAbsReal& _phase_2perp,
		ACCEPTANCE_FUNCTION _acceptance_function,
		MHI_PDG_constants _s_PDG,
		MHI_CacheIntegrators_4D _s_4D,
		MHI_CacheIntegrators_3D_phi_th1_th2 _s_3D_phi_th1_th2,
		MHI_CacheIntegrators_3D_m_th1_th2 _s_3D_m_th1_th2,
		MHI_CacheIntegrators_3D_m_phi_th2 _s_3D_m_phi_th2,
		MHI_CacheIntegrators_3D_m_phi_th1 _s_3D_m_phi_th1) :
		RooAbsPdf(name,title),
		m("m","m",this,_m),
		phi("phi","phi",this,_phi),
		cos_th1("cos_th1","cos_th1",this,_cos_th1),
		cos_th2("cos_th2","cos_th2",this,_cos_th2),
		mass_0("mass_0","mass_0",this,_mass_0),
		width_0("width_0","width_0",this,_width_0),
		a("a","a",this,_a),
		b("b","b",this,_b),
		mass_1("mass_1","mass_1",this,_mass_1),
		width_1("width_1","width_1",this,_width_1),
		r_1("r_1","r_1",this,_r_1),
		mass_2("mass_2","mass_2",this,_mass_2),
		width_2("width_2","width_2",this,_width_2),
		r_2("r_2","r_2",this,_r_2),
		amp_00("amp_00","amp_00",this,_amp_00),
		phase_00("phase_00","phase_00",this,_phase_00),
		amp_10("amp_10","amp_10",this,_amp_10),
		phase_10("phase_10","phase_10",this,_phase_10),
		amp_1para("amp_1para","amp_1para",this,_amp_1para),
		phase_1para("phase_1para","phase_1para",this,_phase_1para),
		amp_1perp("amp_1perp","amp_1perp",this,_amp_1perp),
		phase_1perp("phase_1perp","phase_1perp",this,_phase_1perp),
		amp_20("amp_20","amp_20",this,_amp_20),
		phase_20("phase_20","phase_20",this,_phase_20),
		amp_2para("amp_2para","amp_2para",this,_amp_2para),
		phase_2para("phase_2para","phase_2para",this,_phase_2para),
		amp_2perp("amp_2perp","amp_2perp",this,_amp_2perp),
		phase_2perp("phase_2perp","phase_2perp",this,_phase_2perp),
		m_Pi(_s_PDG.m_Pi),
		m_K(_s_PDG.m_K),
		m_Phi(_s_PDG.m_Phi),
		m_B0(_s_PDG.m_B0),
		m_acceptance_function(_acceptance_function),
		m_norm_cache_integrator(_s_4D.norm_cache_integrator),
		m_real_cache_integrator(_s_4D.real_cache_integrator),
		m_imag_cache_integrator(_s_4D.imag_cache_integrator),
		m_norm_cache_integrator_phi_th1_th2(_s_3D_phi_th1_th2.norm_cache_integrator_phi_th1_th2),
		m_real_cache_integrator_phi_th1_th2(_s_3D_phi_th1_th2.real_cache_integrator_phi_th1_th2),
		m_imag_cache_integrator_phi_th1_th2(_s_3D_phi_th1_th2.imag_cache_integrator_phi_th1_th2),
		m_norm_cache_integrator_m_th1_th2(_s_3D_m_th1_th2.norm_cache_integrator_m_th1_th2),
		m_real_cache_integrator_m_th1_th2(_s_3D_m_th1_th2.real_cache_integrator_m_th1_th2),
		m_imag_cache_integrator_m_th1_th2(_s_3D_m_th1_th2.imag_cache_integrator_m_th1_th2),
		m_norm_cache_integrator_m_phi_th2(_s_3D_m_phi_th2.norm_cache_integrator_m_phi_th2),
		m_real_cache_integrator_m_phi_th2(_s_3D_m_phi_th2.real_cache_integrator_m_phi_th2),
		m_imag_cache_integrator_m_phi_th2(_s_3D_m_phi_th2.imag_cache_integrator_m_phi_th2),
		m_norm_cache_integrator_m_phi_th1(_s_3D_m_phi_th1.norm_cache_integrator_m_phi_th1),
		m_real_cache_integrator_m_phi_th1(_s_3D_m_phi_th1.real_cache_integrator_m_phi_th1),
		m_imag_cache_integrator_m_phi_th1(_s_3D_m_phi_th1.imag_cache_integrator_m_phi_th1){
}

RooMassHelicityAngles_TransformedBase::RooMassHelicityAngles_TransformedBase(const RooMassHelicityAngles_TransformedBase& other, const char* name) :
	   RooAbsPdf(other,name),
	   m("m",this,other.m),
	   phi("phi",this,other.phi),
	   cos_th1("cos_th1",this,other.cos_th1),
	   cos_th2("cos_th2",this,other.cos_th2),
	   mass_0("mass_0",this,other.mass_0),
	   width_0("width_0",this,other.width_0),
	   a("a",this,other.a),
	   b("b",this,other.b),
	   mass_1("mass_1",this,other.mass_1),
	   width_1("width_1",this,other.width_1),
	   r_1("r_1",this,other.r_1),
	   mass_2("mass_2",this,other.mass_2),
	   width_2("width_2",this,other.width_2),
	   r_2("r_2",this,other.r_2),
	   amp_00("amp_00",this,other.amp_00),
	   phase_00("phase_00",this,other.phase_00),
	   amp_10("amp_10",this,other.amp_10),
	   phase_10("phase_10",this,other.phase_10),
	   amp_1para("amp_1para",this,other.amp_1para),
	   phase_1para("phase_1para",this,other.phase_1para),
	   amp_1perp("amp_1perp",this,other.amp_1perp),
	   phase_1perp("phase_1perp",this,other.phase_1perp),
	   amp_20("amp_20",this,other.amp_20),
	   phase_20("phase_20",this,other.phase_20),
	   amp_2para("amp_2para",this,other.amp_2para),
	   phase_2para("phase_2para",this,other.phase_2para),
	   amp_2perp("amp_2perp",this,other.amp_2perp),
	   phase_2perp("phase_2perp",this,other.phase_2perp),
	   m_Pi(other.m_Pi),
	   m_K(other.m_K),
	   m_Phi(other.m_Phi),
	   m_B0(other.m_B0),
	   m_acceptance_function(other.m_acceptance_function),
	   m_norm_cache_integrator(other.m_norm_cache_integrator),
	   m_real_cache_integrator(other.m_real_cache_integrator),
	   m_imag_cache_integrator(other.m_imag_cache_integrator),
	   m_norm_cache_integrator_phi_th1_th2(other.m_norm_cache_integrator_phi_th1_th2),
	   m_real_cache_integrator_phi_th1_th2(other.m_real_cache_integrator_phi_th1_th2),
	   m_imag_cache_integrator_phi_th1_th2(other.m_imag_cache_integrator_phi_th1_th2),
	   m_norm_cache_integrator_m_th1_th2(other.m_norm_cache_integrator_m_th1_th2),
	   m_real_cache_integrator_m_th1_th2(other.m_real_cache_integrator_m_th1_th2),
	   m_imag_cache_integrator_m_th1_th2(other.m_imag_cache_integrator_m_th1_th2),
	   m_norm_cache_integrator_m_phi_th2(other.m_norm_cache_integrator_m_phi_th2),
	   m_real_cache_integrator_m_phi_th2(other.m_real_cache_integrator_m_phi_th2),
	   m_imag_cache_integrator_m_phi_th2(other.m_imag_cache_integrator_m_phi_th2),
	   m_norm_cache_integrator_m_phi_th1(other.m_norm_cache_integrator_m_phi_th1),
	   m_real_cache_integrator_m_phi_th1(other.m_real_cache_integrator_m_phi_th1),
	   m_imag_cache_integrator_m_phi_th1(other.m_imag_cache_integrator_m_phi_th1){
}

Double_t RooMassHelicityAngles_TransformedBase::evaluate() const {
	// amplitude vectors J=0,1,2
	// Spin J=0 (only long.)
	std::vector<std::complex<double> > A_0; A_0.reserve(1);
	A_0.push_back(std::polar((double)amp_00,(double)phase_00));
	// Spin J=1 (lambda -1,0,1)
	std::complex<double> A_1para = std::polar((double)amp_1para,(double)phase_1para);
	std::complex<double> A_1perp = std::polar((double)amp_1perp,(double)phase_1perp);
	std::vector<std::complex<double> > A_1; A_1.reserve(3);
	A_1.push_back((A_1para - A_1perp)/std::sqrt(2));
	A_1.push_back(std::polar((double)amp_10,(double)phase_10));
	A_1.push_back((A_1para + A_1perp)/std::sqrt(2));
	// Spin J=2 (lambda -1,0,1)
	std::complex<double> A_2para = std::polar((double)amp_2para,(double)phase_2para);
	std::complex<double> A_2perp = std::polar((double)amp_2perp,(double)phase_2perp);
	std::vector<std::complex<double> > A_2; A_2.reserve(3);
	A_2.push_back((A_2para - A_2perp)/std::sqrt(2));
	A_2.push_back(std::polar((double)amp_20,(double)phase_20));
	A_2.push_back((A_2para + A_2perp)/std::sqrt(2));
	// calculate momentum in rest frame of resonances
	double q = ComplexPDF::CalculateMomentum(m,m_Pi,m_K);
	double q_0 = ComplexPDF::CalculateMomentum(mass_0,m_Pi,m_K);
	double q_1 = ComplexPDF::CalculateMomentum(mass_1,m_Pi,m_K);
	double q_2 = ComplexPDF::CalculateMomentum(mass_2,m_Pi,m_K);

	double acos_cos_th1 = std::acos(cos_th1);
	double acos_cos_th2 = std::acos(cos_th2);

	std::complex<double> lass = ComplexPDF::LASS(m,mass_0,width_0,a,b,q,q_0);
	std::complex<double> rbw_1 = ComplexPDF::RelativisticSpinBreitWigner(m,mass_1,width_1,r_1,1,q,q_1);
	std::complex<double> rbw_2 = ComplexPDF::RelativisticSpinBreitWigner(m,mass_2,width_2,r_2,2,q,q_2);
	std::complex<double> angular_0 = ComplexPDF::HelicityAngles(phi,acos_cos_th1,acos_cos_th2,0,1,A_0);
	std::complex<double> angular_1 = ComplexPDF::HelicityAngles(phi,acos_cos_th1,acos_cos_th2,1,1,A_1);
	std::complex<double> angular_2 = ComplexPDF::HelicityAngles(phi,acos_cos_th1,acos_cos_th2,2,1,A_2);

	// result amplitude
	std::complex<double> amplitude = angular_0 * lass + angular_1 * rbw_1 + angular_2 * rbw_2;
	// phase space factor
	double F = ComplexPDF::PhaseSpaceFactor(m,m_B0,m_Pi,m_K,m_Phi);
	// acceptance function
	double acceptance = GetEff(m,phi,acos_cos_th1,acos_cos_th2,m_acceptance_function);
	// return |A|^2
	return acceptance * std::norm(amplitude) * F;
}

Int_t RooMassHelicityAngles_TransformedBase::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
	if (matchArgs(allVars, analVars, m, phi, cos_th1, cos_th2))
		return 5;
	if (matchArgs(allVars, analVars, phi, cos_th1, cos_th2))
		return 4;
	if (matchArgs(allVars, analVars, m, cos_th1, cos_th2))
		return 3;
	if (matchArgs(allVars, analVars, m, phi, cos_th2))
		return 2;
	if (matchArgs(allVars, analVars, m, phi, cos_th1))
		return 1;
	//std::cerr << "INFO: Unsupported analytical integral was requested in RooMassHelicityAnglesTest::getAnalyticalIntegral(...) " <<
	//		"--> Numeric integration will be used." <<  std::endl;
	return 0;
}

Double_t RooMassHelicityAngles_TransformedBase::analyticalIntegral(Int_t code, const char* rangeName ) const {
	// J and lambda values of each amplitude
	const double J_values[7]      = {0, 1,1,1, 2,2,2};
	const double lambda_values[7] = {0,-1,0,1,-1,0,1};
	// complex weights
	std::complex<double> A_1para = std::polar((double)amp_1para,(double)phase_1para);
	std::complex<double> A_1perp = std::polar((double)amp_1perp,(double)phase_1perp);
	std::complex<double> A_2para = std::polar((double)amp_2para,(double)phase_2para);
	std::complex<double> A_2perp = std::polar((double)amp_2perp,(double)phase_2perp);
	const double amps[7]  = {amp_00,  std::abs((A_1para - A_1perp)/std::sqrt(2)),  amp_10,std::abs((A_1para + A_1perp)/std::sqrt(2)),std::abs((A_2para - A_2perp)/std::sqrt(2)),  amp_20,std::abs((A_2para + A_2perp)/std::sqrt(2))};
	const double phase[7] = {phase_00,std::arg((A_1para - A_1perp)/std::sqrt(2)),phase_10,std::arg((A_1para + A_1perp)/std::sqrt(2)),std::arg((A_2para - A_2perp)/std::sqrt(2)),phase_20,std::arg((A_2para + A_2perp)/std::sqrt(2))};

	// parameters index 0-17 are same for all integrals
	// index 18 is the acceptance function used
	// index 19 might be one of the variables
	std::vector<double> parameters;
	parameters.reserve(20);
	parameters.assign(19,0);
	// variable parameters (will be set in for loop below)
	parameters[0] = 0; // J
	parameters[1] = 0; // lambda
	parameters[2] = 0; // J_cc
	parameters[3] = 0; // lambda_cc
	// constant parameters for resonances
	parameters[4] = mass_0;
	parameters[5] = width_0;
	parameters[6] = a;
	parameters[7] = b;
	parameters[8] = mass_1;
	parameters[9] = width_1;
	parameters[10] = r_1;
	parameters[11] = mass_2;
	parameters[12] = width_2;
	parameters[13] = r_2;
	// constant parameters
	parameters[14] = m_B0;
	parameters[15] = m_Pi;
	parameters[16] = m_K;
	parameters[17] = m_Phi;
	// acceptance function
	parameters[18] = m_acceptance_function;

	if (code == 5) {
		std::vector<std::pair<double,double> > limits; limits.reserve(4);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 4) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(m);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_phi_th1_th2->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_phi_th1_th2->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_phi_th1_th2->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 3) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(phi);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_m_th1_th2->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_m_th1_th2->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_m_th1_th2->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 2) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th2.min(rangeName),cos_th2.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(cos_th1);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_m_phi_th2->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_m_phi_th2->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_m_phi_th2->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	} else if (code == 1) {
		std::vector<std::pair<double,double> > limits; limits.reserve(3);
		limits.push_back(std::make_pair(m.min(rangeName),m.max(rangeName)));
		limits.push_back(std::make_pair(phi.min(rangeName),phi.max(rangeName)));
		limits.push_back(std::make_pair(cos_th1.min(rangeName),cos_th1.max(rangeName)));
		// swap limits if necessary
		for(unsigned int i = 0; i < limits.size(); ++i) {
			if(limits[i].first > limits[i].second) {
				std::swap(limits[i].first, limits[i].second);
			}
		}
		// fixed dimensions mass
		parameters.push_back(cos_th2);

		// matrix element
		double M = 0;
		// calc each of the 49 terms (some need to be recalculated probably, some are done and fast)
		for(unsigned int i = 0; i < 7; ++i) {
			for(unsigned int j = 0; j < 7; ++j) {
				// setting missing paramters
				parameters[0] = J_values[i];
				parameters[1] = lambda_values[i];
				parameters[2] = J_values[j];
				parameters[3] = lambda_values[j];
				// switch between the three different types of integrals
				if(i==j) { // integral |A_i|^2
					M += amps[i]*amps[j]*m_norm_cache_integrator_m_phi_th1->GetIntegral(limits,parameters);
				} else if (i < j) { // integral Re(A_i A_j*)
					M += 2*amps[i]*amps[j]*std::cos(phase[i]-phase[j])*m_real_cache_integrator_m_phi_th1->GetIntegral(limits,parameters);
				} else if (i > j) { // integral Im(A_i A_j*)
					// flip i and j components, as always A_j needs to be cc
					std::swap(parameters[0],parameters[2]);
					std::swap(parameters[1],parameters[3]);
					M -= 2*amps[i]*amps[j]*std::sin(phase[j]-phase[i])*m_imag_cache_integrator_m_phi_th1->GetIntegral(limits,parameters);
				}
			}
		}
		return M;
	}
	std::cerr << "ERROR: Unsupported analytical integral code=" << code << " in RooMassHelicityAnglesTest::analyticalIntegral(...) " <<
			"--> Return 0" << std::endl;
	return 0;
}

