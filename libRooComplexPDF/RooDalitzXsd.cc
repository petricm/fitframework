/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooDalitzXsd.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "RooMath.h"
#include "TMath.h"

#include <complex>
#include "libComplexPDF/libComplexPDF.h"

ClassImp(RooDalitzXsd)

RooDalitzXsd::RooDalitzXsd(const char *name, const char *title,
                               RooAbsReal& _m12,
                               RooAbsReal& _m23,
                               RooAbsReal& _mean1,
                               RooAbsReal& _mean2,
                               RooAbsReal& _sigma1,
                               RooAbsReal& _sigma2,
                               RooAbsReal& _border,
                               RooAbsReal& _c1,
                               RooAbsReal& _c2,
                               RooAbsReal& _c3,
                               RooAbsReal& _c4,
                               int _comb,
                               double _m1,
                               double _m2,
                               double _m3,
                               double _mM) :
RooAbsPdf(name,title),
m12("m12","m12",this,_m12),
m23("m23","m23",this,_m23),
mean1("mean1","mean1",this,_mean1),
mean2("mean2","mean2",this,_mean2),
sigma1("sigma1","sigma1",this,_sigma1),
sigma2("sigma2","sigma2",this,_sigma2),
border("border","border",this,_border),
c1("c1","c1",this,_c1),
c2("c2","c2",this,_c2),
c3("c3","c3",this,_c3),
c4("c4","c4",this,_c4),
comb(_comb),
m1(_m1),
m2(_m2),
m3(_m3),
mM(_mM) {
}

RooDalitzXsd::RooDalitzXsd(const RooDalitzXsd& other, const char* name) :
RooAbsPdf(other,name),
m12("m12",this,other.m12),
m23("m23",this,other.m23),
mean1("mean1",this,other.mean1),
mean2("mean2",this,other.mean2),
sigma1("sigma1",this,other.sigma1),
sigma2("sigma2",this,other.sigma2),
border("border",this,other.border),
c1("c1",this,other.c1),
c2("c2",this,other.c2),
c3("c3",this,other.c3),
c4("c4",this,other.c4),
comb(other.comb),
m1(other.m1),
m2(other.m2),
m3(other.m3),
mM(other.mM) {
}

Double_t RooDalitzXsd::evaluate() const {
	double sqrt_m12 = std::sqrt(m12);
	double sqrt_m23 = std::sqrt(m23);
    double m31 = m1*m1 + m2*m2 + m3*m3 + mM*mM - m12 -m23;
	if(ComplexPDF::InsideDalitzLimits(sqrt_m12,sqrt_m23,mM,m1,m2,m3)) {
		
        if (comb==12) {
            double gauss = 0;
            
            if (m12>border) {
                gauss = mean1*TMath::Exp(m12 * sigma1);
            }else{
                gauss = TMath::Gaus(m12,mean2,sigma2,true);
            }
            
            double x_min = (m2+m3)*(m2+m3);
            double x_max = (mM-m1)*(mM-m1);
            double x0 = m23 - (x_max-x_min)/2.0 ;
            Double_t poly = std::abs(1 + c1*x0 + c2*(2*x0*x0 - 1) + c3*(4*x0*x0*x0 - 3*x0) + c4*(8*x0*x0*x0*x0-8*x0*x0+1));
            return gauss*poly;
        }
        
        if (comb==23) {
            double gauss = 0;
            if (m23>border) {
                gauss = mean1*TMath::Exp(m23 * sigma1);
            }else{
                gauss = TMath::Gaus(m23,mean2,sigma2,true);
            }
            double x_min = (m1+m3)*(m1+m3);
            double x_max = (mM-m2)*(mM-m2);
            double x0 = m31 - (x_max-x_min)/2.0 ;
            Double_t poly = std::abs(1 + c1*x0 + c2*(2*x0*x0 - 1) + c3*(4*x0*x0*x0 - 3*x0) + c4*(8*x0*x0*x0*x0-8*x0*x0+1));
            return gauss*poly;
        }
        
        if (comb==31) {
            double gauss = 0;
            if (m31>border) {
                gauss = mean1*TMath::Exp(m31 * sigma1);
            }else{
                gauss = TMath::Gaus(m31,mean2,sigma2,true);
            }
            double x_min = (m1+m2)*(m1+m2);
            double x_max = (mM-m3)*(mM-m3);
            double x0 = m12 - (x_max-x_min)/2.0 ;
            Double_t poly = std::abs(1 + c1*x0 + c2*(2*x0*x0 - 1) + c3*(4*x0*x0*x0 - 3*x0) + c4*(8*x0*x0*x0*x0-8*x0*x0+1));
            return gauss*poly;
        }
        
	} else {
		return 1.0e-5;
	}
}


Int_t RooDalitzXsd::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /* rangeName */) const {
	
    //if (matchArgs(allVars, analVars, m12, m23))
	//	return 1;
	//std::cerr << "INFO: Unsupported analytical integral was requested in RooDalitzAnalysis::getAnalyticalIntegral(...) " <<
	//		"--> Numeric integration will be used." <<  std::endl;
	return 0;
}


Double_t RooDalitzXsd::analyticalIntegral(Int_t code, const char* rangeName ) const {
   
	std::cerr << "ERROR: Unsupported analytical integral code=" << code << " in RooDalitzXsd::analyticalIntegral(...) " <<
    "--> Return 0" << std::endl;
	return 0;
}



